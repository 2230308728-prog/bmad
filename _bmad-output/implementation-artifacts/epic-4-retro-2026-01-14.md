# Epic 4 回顾：预订与支付系统

**回顾日期：** 2026-01-14
**Epic 周期：** 2026-01-14 - 2026-01-14
**参与者：** 开发团队

---

## Epic 概述

Epic 4 实现了完整的预订与支付功能，支持家长用户提交预订、集成微信支付 JSAPI、处理支付回调、查询支付结果。

### 业务目标

✅ 家长可以提交产品预订信息创建订单
✅ 系统集成微信支付 JSAPI，支持小程序内支付
✅ 系统能够接收并处理微信支付异步回调通知
✅ 家长可以查询订单支付状态并获取最新结果

### 完成的 Stories

| Story | 描述 | 状态 | 提交记录 |
|-------|------|------|----------|
| 4.1 | 设计订单数据模型 | ✅ done | (已包含在其他提交中) |
| 4.2 | 实现预订信息提交 API | ✅ done | (已包含在其他提交中) |
| 4.3 | 集成微信支付 JSAPI | ✅ done | 973a84e |
| 4.4 | 实现支付结果异步回调处理 | ✅ done | fdb8abe |
| 4.5 | 实现支付结果查询与展示 | ✅ done | 435f156 |

---

## 技术实现亮点

### 1. 数据模型设计 (Story 4.1)

创建了完整的订单和支付数据模型：

- **Order 模型**：支持多种订单状态（PENDING, PAID, CANCELLED, REFUNDED, COMPLETED）
- **OrderItem 模型**：支持产品快照（价格、名称），保证历史数据准确性
- **PaymentRecord 模型**：支持多渠道支付记录，保留完整的支付流水

### 2. 库存预扣机制 (Story 4.2)

使用 Redis 原子操作实现库存预扣：

```typescript
// 预扣库存：DECRBY product:stock:{productId} quantity
const newStock = await cacheService.decrby(stockKey, quantity);
if (newStock < 0) {
  // 库存不足，回滚
  await cacheService.incrby(stockKey, quantity);
  throw new BadRequestException('库存不足');
}
```

**优势：**
- 原子操作保证并发安全
- 避免超卖问题
- 失败自动回滚

### 3. 微信支付集成 (Story 4.3)

使用 `wechatpay-node-v3` SDK 集成微信支付 API v3：

- 创建 JSAPI 支付订单，获取 prepayId
- 生成小程序调起支付参数（ timeStamp, nonceStr, package, signType, paySign ）
- 使用商户私钥 RSA 签名
- 完整的错误处理和日志记录

**技术挑战：**
- SDK 类型定义与实际使用不完全匹配，使用 `any` 类型 + 详细注释
- 商户私钥从文件系统读取，需要正确配置路径

### 4. 支付回调处理 (Story 4.4)

实现了幂等的支付回调处理：

```typescript
// 查询订单是否已处理
const existingPayment = await prisma.paymentRecord.findFirst({
  where: { transactionId: decryptedData.transaction_id }
});

if (existingPayment && existingPayment.status === PaymentStatus.SUCCESS) {
  return { return_code: 'SUCCESS', return_msg: 'OK' }; // 幂等返回
}
```

**安全性：**
- 验证微信签名（timestamp, nonce, body, serial, signature）
- 解密回调数据（AES-256-GCM）
- 事务保证数据一致性（订单状态 + 支付记录 + 产品计数 + 缓存清除）

### 5. 支付状态查询 (Story 4.5)

实现了主动查询 + 频率限制：

```typescript
// 本地状态检查
if (order.status === OrderStatus.PAID) {
  return paymentSuccessResponse;
}

// 主动查询微信支付
const wechatResult = await wechatPayService.queryOrder(order.orderNo);

// 频率限制：每分钟最多 10 次
const isRateLimited = await checkPaymentQueryRateLimit(orderId);
if (isRateLimited) {
  response.setHeader('Retry-After', '60');
  throw new HttpException('查询频率超限', 429);
}
```

**代码审查修复：**
- 添加 Retry-After 响应头
- 添加 Redis incr null 检查
- 添加微信响应数据验证（transaction_id, success_time, amount.total）

---

## 测试覆盖

### 单元测试统计

| Story | OrdersService | OrdersController | WechatPayService | 总计 |
|-------|---------------|------------------|------------------|------|
| 4.2 | 9 | 6 | - | 15 |
| 4.3 | - | - | 8 | 8 |
| 4.4 | 10 (回调) | 7 (回调) | - | 17 |
| 4.5 | 25 | 11 | - | 36 |
| **总计** | **44** | **24** | **8** | **76** |

### 测试场景覆盖

✅ 订单创建成功场景
✅ 产品不存在/已下架
✅ 库存不足
✅ 年龄范围不符
✅ Redis 库存预扣失败/回滚
✅ 事务失败回滚
✅ 微信支付订单创建成功
✅ JSAPI 支付参数生成
✅ 支付回调签名验证
✅ 支付成功处理（幂等性）
✅ 支付失败处理（库存释放）
✅ 支付状态查询（PAID/PENDING/CANCELLED）
✅ 频率限制（Retry-After 头）
✅ 微信响应数据验证

### 代码覆盖率

- OrdersService: ~85%
- OrdersController: ~90%
- WechatPayService: ~80%

---

## 遇到的挑战与解决方案

### 挑战 1: Redis 库存预扣的并发安全

**问题：** 多个用户同时预订同一产品，可能导致超卖

**解决方案：**
- 使用 Redis DECRBY 原子操作
- 检查返回值是否为负数
- 负数时回滚库存并返回错误

### 挑战 2: 微信支付 SDK 类型不匹配

**问题：** `wechatpay-node-v3` SDK 的类型定义与实际使用不完全一致

**解决方案：**
- 使用 `any` 类型 + 详细注释说明
- 封装 TypeScript 接口（JsapiPaymentParams, WechatPayOrderQueryResult）
- 验证关键响应字段

### 挑战 3: 支付回调的幂等性

**问题：** 微信可能重复发送回调通知

**解决方案：**
- 查询 PaymentRecord 表判断是否已处理
- 已处理的订单直接返回成功
- 使用事务保证数据一致性

### 挑战 4: Retry-After 响应头缺失

**问题：** 429 错误未添加 Retry-After 响应头（代码审查发现）

**解决方案：**
- 使用 `@Res({ passthrough: true })` 注入 Response 对象
- 在抛出 429 异常前设置 `response.setHeader('Retry-After', '60')`

### 挑战 5: Redis incr 操作缺少 null 检查

**问题：** `cacheService.incr()` 可能返回 null（代码审查发现）

**解决方案：**
- 添加 null 检查
- Redis 操作失败时返回 true（限制请求）

---

## 经验教训

### 做得好的方面 ✅

1. **原子操作保证并发安全**：Redis DECRBY/INCRBY 有效避免了超卖
2. **事务保证数据一致性**：支付成功处理使用 Prisma 事务
3. **幂等性设计**：支付回调处理支持重复通知
4. **完善的错误处理**：所有 Redis 操作失败都有回滚机制
5. **频率限制保护**：支付状态查询限制频率，避免滥用
6. **代码审查发现潜在问题**：5 个问题（2 HIGH, 3 MEDIUM）全部修复

### 需要改进的方面 ⚠️

1. **类型安全**：微信支付 SDK 使用 `any` 类型，虽然加了注释但不够理想
2. **测试覆盖**：WechatPayService 覆盖率约 80%，可以进一步提升
3. **错误消息**：部分错误消息暴露内部实现细节（已部分修复）
4. **文档更新**：tsconfig.json 未及时记录到 File List（已修复）

---

## 改进建议

### 短期改进

1. **增强类型安全**
   - 为微信支付 SDK 创建完整的类型定义文件
   - 减少 `any` 类型的使用

2. **提升测试覆盖**
   - WechatPayService 目标覆盖率：90%+
   - 添加集成测试覆盖完整的支付流程

3. **优化错误处理**
   - 统一错误码和错误消息
   - 避免暴露内部实现细节

### 长期改进

1. **支付渠道抽象**
   - 设计统一的支付接口（支持微信、支付宝等）
   - 使用策略模式切换支付渠道

2. **监控和告警**
   - 添加支付成功率监控
   - 支付失败告警（回调异常、库存异常）

3. **性能优化**
   - 支付回调处理性能分析
   - Redis 操作性能监控

---

## 下一步行动

### Epic 5 准备

Epic 5 将实现订单管理与通知功能：

- 5.1: 实现家长端订单列表和详情查询
- 5.2: 实现管理员订单管理 API
- 5.3: 设计退款数据模型
- 5.4: 实现家长退款申请
- 5.5: 实现管理员退款审核
- 5.6: 集成微信支付退款
- 5.7: 实现微信订阅通知

### 技术债务

- [ ] 创建微信支付 SDK 完整类型定义
- [ ] 提升 WechatPayService 测试覆盖率到 90%+
- [ ] 统一错误码和错误消息
- [ ] 添加支付监控和告警

---

## 总结

Epic 4 成功实现了完整的预订与支付功能，支持微信支付 JSAPI、支付回调处理、支付状态查询。系统具有良好的并发安全性和数据一致性保障。

**关键成就：**
- 5 个 Stories 全部完成
- 76 个单元测试全部通过
- 代码审查发现并修复 5 个问题

**待改进项：**
- 提升类型安全（减少 `any` 使用）
- 提升测试覆盖率
- 统一错误处理

Epic 4 为系统的核心支付功能奠定了坚实基础，为 Epic 5 的订单管理与退款功能提供了良好的技术支撑。
